// backend/src/controllers/company.controller.js
const { db } = require('../config/firebase');
const { calculateAdvancedMatchScore } = require('../services/matching.service');
const { sendJobNotification } = require('../services/email.service');

// Profile Management
exports.getProfile = async (req, res) => {
  try {
    const companyDoc = await db.collection('companies').doc(req.user.uid).get();
    
    if (!companyDoc.exists) {
      return res.status(404).json({ error: 'Company profile not found' });
    }

    res.json({ id: companyDoc.id, ...companyDoc.data() });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

exports.updateProfile = async (req, res) => {
  try {
    const updateData = {
      ...req.body,
      updatedAt: new Date()
    };

    await db.collection('companies').doc(req.user.uid).update(updateData);
    
    res.json({ message: 'Profile updated successfully' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// Get Dashboard Statistics
exports.getDashboardStats = async (req, res) => {
  try {
    const companyId = req.user.uid;

    // Get all jobs
    const jobsSnapshot = await db.collection('jobs')
      .where('companyId', '==', companyId)
      .get();

    const activeJobs = jobsSnapshot.docs.filter(doc => doc.data().status === 'active');

    // Get all applications
    const applicationsSnapshot = await db.collection('jobApplications')
      .where('companyId', '==', companyId)
      .get();

    const applications = applicationsSnapshot.docs.map(doc => doc.data());

    // Calculate statistics
    const stats = {
      totalJobs: jobsSnapshot.size,
      activeJobs: activeJobs.length,
      totalApplications: applications.length,
      qualifiedApplicants: applications.filter(app => app.matchScore >= 70).length,
      interviewReady: applications.filter(app => app.qualificationStatus === 'interview-ready').length,
      averageMatchScore: applications.length > 0
        ? Math.round(applications.reduce((sum, app) => sum + app.matchScore, 0) / applications.length)
        : 0,
      pendingReviews: applications.filter(app => app.status === 'pending').length
    };

    res.json(stats);
  } catch (error) {
    console.error('Error fetching dashboard stats:', error);
    res.status(500).json({ error: error.message });
  }
};

// Job Management with Automatic Qualification System
exports.postJob = async (req, res) => {
  try {
    const companyId = req.user.uid;
    
    // Check if company is approved
    const companyDoc = await db.collection('companies').doc(companyId).get();
    if (!companyDoc.exists || companyDoc.data().status !== 'approved') {
      return res.status(403).json({ error: 'Company account must be approved to post jobs' });
    }

    const jobData = {
      companyId,
      companyName: companyDoc.data().companyName,
      ...req.body,
      status: 'active',
      postedAt: new Date(),
      applicantCount: 0,
      qualifiedCount: 0,
      interviewReadyCount: 0,
      // Define qualification thresholds
      qualificationCriteria: {
        minimumMatchScore: req.body.minimumMatchScore || 70,
        interviewReadyScore: req.body.interviewReadyScore || 85,
        autoReject: req.body.autoReject !== false
      }
    };

    const jobRef = await db.collection('jobs').add(jobData);

    // Find and auto-filter qualified students
    const qualifiedStudents = await findAndRankQualifiedStudents(jobRef.id, jobData);
    
    // Create pre-filtered applications for qualified students only
    let notifiedCount = 0;
    let interviewReadyCount = 0;

    for (const student of qualifiedStudents) {
      if (student.matchScore >= jobData.qualificationCriteria.minimumMatchScore) {
        // Create application record
        const applicationData = {
          jobId: jobRef.id,
          studentId: student.studentId,
          companyId: companyId,
          matchScore: student.matchScore,
          scoreBreakdown: student.scoreBreakdown,
          qualificationStatus: student.matchScore >= jobData.qualificationCriteria.interviewReadyScore 
            ? 'interview-ready' 
            : 'qualified',
          appliedAt: new Date(),
          status: 'pending',
          autoGenerated: true,
          reviewRequired: student.matchScore < jobData.qualificationCriteria.interviewReadyScore
        };

        await db.collection('jobApplications').add(applicationData);

        // Create notification for student
        await db.collection('notifications').add({
          userId: student.studentId,
          type: 'job_match',
          title: 'Perfect Job Match Found!',
          message: `You match ${student.matchScore}% with "${jobData.title}" at ${companyDoc.data().companyName}`,
          read: false,
          relatedId: jobRef.id,
          matchScore: student.matchScore,
          createdAt: new Date()
        });

        // Send email notification
        if (student.email && sendJobNotification) {
          try {
            await sendJobNotification(
              student.email, 
              student.studentName, 
              jobData.title, 
              companyDoc.data().companyName,
              student.matchScore
            );
          } catch (emailError) {
            console.error('Email notification failed:', emailError);
          }
        }

        notifiedCount++;
        if (student.matchScore >= jobData.qualificationCriteria.interviewReadyScore) {
          interviewReadyCount++;
        }
      }
    }

    // Update job with counts
    await jobRef.update({
      qualifiedCount: notifiedCount,
      interviewReadyCount: interviewReadyCount
    });

    res.status(201).json({
      message: 'Job posted successfully with automatic qualification filtering',
      jobId: jobRef.id,
      statistics: {
        totalQualified: notifiedCount,
        interviewReady: interviewReadyCount,
        averageMatchScore: qualifiedStudents.length > 0 
          ? Math.round(qualifiedStudents.reduce((sum, s) => sum + s.matchScore, 0) / qualifiedStudents.length)
          : 0
      }
    });
  } catch (error) {
    console.error('Error posting job:', error);
    res.status(500).json({ error: error.message });
  }
};

// Get all jobs for this company
exports.getMyJobs = async (req, res) => {
  try {
    const jobsSnapshot = await db.collection('jobs')
      .where('companyId', '==', req.user.uid)
      .orderBy('postedAt', 'desc')
      .get();

    const jobs = jobsSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    res.json(jobs);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// Get specific job
exports.getJobById = async (req, res) => {
  try {
    const jobDoc = await db.collection('jobs').doc(req.params.id).get();
    
    if (!jobDoc.exists) {
      return res.status(404).json({ error: 'Job not found' });
    }

    const jobData = jobDoc.data();

    // Verify ownership
    if (jobData.companyId !== req.user.uid) {
      return res.status(403).json({ error: 'Access denied' });
    }

    res.json({ id: jobDoc.id, ...jobData });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// Update job
exports.updateJob = async (req, res) => {
  try {
    const jobDoc = await db.collection('jobs').doc(req.params.id).get();
    
    if (!jobDoc.exists) {
      return res.status(404).json({ error: 'Job not found' });
    }

    if (jobDoc.data().companyId !== req.user.uid) {
      return res.status(403).json({ error: 'Access denied' });
    }

    await db.collection('jobs').doc(req.params.id).update({
      ...req.body,
      updatedAt: new Date()
    });

    res.json({ message: 'Job updated successfully' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// Delete job
exports.deleteJob = async (req, res) => {
  try {
    const jobDoc = await db.collection('jobs').doc(req.params.id).get();
    
    if (!jobDoc.exists) {
      return res.status(404).json({ error: 'Job not found' });
    }

    if (jobDoc.data().companyId !== req.user.uid) {
      return res.status(403).json({ error: 'Access denied' });
    }

    await db.collection('jobs').doc(req.params.id).delete();

    res.json({ message: 'Job deleted successfully' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// Close job
exports.closeJob = async (req, res) => {
  try {
    const jobDoc = await db.collection('jobs').doc(req.params.id).get();
    
    if (!jobDoc.exists) {
      return res.status(404).json({ error: 'Job not found' });
    }

    if (jobDoc.data().companyId !== req.user.uid) {
      return res.status(403).json({ error: 'Access denied' });
    }

    await db.collection('jobs').doc(req.params.id).update({
      status: 'closed',
      closedAt: new Date()
    });

    res.json({ message: 'Job closed successfully' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// Get qualified applicants with advanced filtering
exports.getQualifiedApplicants = async (req, res) => {
  try {
    const { jobId } = req.params;
    const { filter = 'all', sortBy = 'matchScore' } = req.query;

    // Verify job ownership
    const jobDoc = await db.collection('jobs').doc(jobId).get();
    if (!jobDoc.exists) {
      return res.status(404).json({ error: 'Job not found' });
    }

    if (jobDoc.data().companyId !== req.user.uid) {
      return res.status(403).json({ error: 'Access denied' });
    }

    const jobData = jobDoc.data();

    // Get applications
    const applicationsSnapshot = await db.collection('jobApplications')
      .where('jobId', '==', jobId)
      .get();

    const applicants = [];

    for (const doc of applicationsSnapshot.docs) {
      const appData = doc.data();
      
      // Apply filter
      if (filter === 'interview-ready' && appData.qualificationStatus !== 'interview-ready') continue;
      if (filter === 'high-match' && appData.matchScore < 80) continue;
      if (filter === 'qualified' && appData.matchScore < 70) continue;
      
      // Get student details
      const studentDoc = await db.collection('students').doc(appData.studentId).get();
      if (studentDoc.exists) {
        const studentData = studentDoc.data();
        
        applicants.push({
          applicationId: doc.id,
          ...appData,
          student: {
            id: studentDoc.id,
            name: `${studentData.personalInfo.firstName} ${studentData.personalInfo.lastName}`,
            email: studentData.personalInfo.email,
            phone: studentData.personalInfo.phone,
            profilePicture: studentData.personalInfo.profilePicture,
            currentInstitution: studentData.admittedInstitution,
            studyStatus: studentData.studyStatus,
            gpa: studentData.completionData?.gpa,
            fieldOfStudy: studentData.completionData?.fieldOfStudy,
            graduationYear: studentData.academicInfo?.graduationYear,
            workExperience: studentData.workExperience,
            certificates: studentData.completionData?.certificates || [],
            documents: studentData.documents
          },
          isInterviewReady: appData.qualificationStatus === 'interview-ready',
          strengthAreas: identifyStrengthAreas(appData.scoreBreakdown),
          concernAreas: identifyConcernAreas(appData.scoreBreakdown)
        });
      }
    }

    // Sort applicants
    if (sortBy === 'matchScore') {
      applicants.sort((a, b) => b.matchScore - a.matchScore);
    } else if (sortBy === 'gpa') {
      applicants.sort((a, b) => (b.student.gpa || 0) - (a.student.gpa || 0));
    } else if (sortBy === 'appliedDate') {
      applicants.sort((a, b) => b.appliedAt.toDate() - a.appliedAt.toDate());
    }

    res.json({
      job: {
        id: jobDoc.id,
        title: jobData.title,
        qualificationCriteria: jobData.qualificationCriteria
      },
      applicants,
      statistics: {
        total: applicants.length,
        interviewReady: applicants.filter(a => a.isInterviewReady).length,
        averageMatchScore: applicants.length > 0 
          ? Math.round(applicants.reduce((sum, a) => sum + a.matchScore, 0) / applicants.length)
          : 0
      }
    });
  } catch (error) {
    console.error('Error fetching qualified applicants:', error);
    res.status(500).json({ error: error.message });
  }
};

// Get applicant detailed profile
exports.getApplicantProfile = async (req, res) => {
  try {
    const { applicationId } = req.params;

    const applicationDoc = await db.collection('jobApplications').doc(applicationId).get();
    
    if (!applicationDoc.exists) {
      return res.status(404).json({ error: 'Application not found' });
    }

    const appData = applicationDoc.data();

    // Verify ownership
    if (appData.companyId !== req.user.uid) {
      return res.status(403).json({ error: 'Access denied' });
    }

    // Get full student details
    const studentDoc = await db.collection('students').doc(appData.studentId).get();
    
    if (!studentDoc.exists) {
      return res.status(404).json({ error: 'Student profile not found' });
    }

    const studentData = studentDoc.data();

    // Get job details
    const jobDoc = await db.collection('jobs').doc(appData.jobId).get();

    res.json({
      application: {
        id: applicationDoc.id,
        ...appData,
        strengthAreas: identifyStrengthAreas(appData.scoreBreakdown),
        concernAreas: identifyConcernAreas(appData.scoreBreakdown)
      },
      student: {
        id: studentDoc.id,
        ...studentData
      },
      job: jobDoc.exists ? { id: jobDoc.id, ...jobDoc.data() } : null
    });
  } catch (error) {
    console.error('Error fetching applicant profile:', error);
    res.status(500).json({ error: error.message });
  }
};

// Update application status
exports.updateApplicationStatus = async (req, res) => {
  try {
    const { applicationId } = req.params;
    const { status, notes } = req.body;
    
    const applicationDoc = await db.collection('jobApplications').doc(applicationId).get();
    
    if (!applicationDoc.exists) {
      return res.status(404).json({ error: 'Application not found' });
    }

    const appData = applicationDoc.data();

    // Verify ownership
    if (appData.companyId !== req.user.uid) {
      return res.status(403).json({ error: 'Access denied' });
    }

    // Update application
    await db.collection('jobApplications').doc(applicationId).update({
      status,
      notes: notes || '',
      reviewedAt: new Date(),
      updatedAt: new Date()
    });

    // Send notification to student
    const studentDoc = await db.collection('students').doc(appData.studentId).get();
    const jobDoc = await db.collection('jobs').doc(appData.jobId).get();

    if (studentDoc.exists && jobDoc.exists) {
      const studentData = studentDoc.data();
      const jobData = jobDoc.data();

      // Create notification
      await db.collection('notifications').add({
        userId: appData.studentId,
        type: 'application_status',
        title: `Application Update: ${jobData.title}`,
        message: getStatusMessage(status, jobData.title, jobData.companyName),
        read: false,
        relatedId: applicationId,
        createdAt: new Date()
      });
    }

    res.json({ message: 'Application status updated successfully' });
  } catch (error) {
    console.error('Error updating application status:', error);
    res.status(500).json({ error: error.message });
  }
};

// Schedule interview (placeholder)
exports.scheduleInterview = async (req, res) => {
  try {
    const { applicationId } = req.params;
    const { interviewDate, interviewTime, location, notes } = req.body;

    const applicationDoc = await db.collection('jobApplications').doc(applicationId).get();
    
    if (!applicationDoc.exists) {
      return res.status(404).json({ error: 'Application not found' });
    }

    const appData = applicationDoc.data();

    if (appData.companyId !== req.user.uid) {
      return res.status(403).json({ error: 'Access denied' });
    }

    // Update application with interview details
    await db.collection('jobApplications').doc(applicationId).update({
      status: 'interview',
      interviewDetails: {
        date: interviewDate,
        time: interviewTime,
        location,
        notes
      },
      updatedAt: new Date()
    });

    // Notify student
    await db.collection('notifications').add({
      userId: appData.studentId,
      type: 'interview_scheduled',
      title: 'Interview Scheduled',
      message: `Your interview has been scheduled for ${interviewDate} at ${interviewTime}`,
      read: false,
      relatedId: applicationId,
      createdAt: new Date()
    });

    res.json({ message: 'Interview scheduled successfully' });
  } catch (error) {
    console.error('Error scheduling interview:', error);
    res.status(500).json({ error: error.message });
  }
};

// Get applicant documents
exports.getApplicantDocuments = async (req, res) => {
  try {
    const { applicationId } = req.params;

    const applicationDoc = await db.collection('jobApplications').doc(applicationId).get();
    
    if (!applicationDoc.exists) {
      return res.status(404).json({ error: 'Application not found' });
    }

    const appData = applicationDoc.data();

    if (appData.companyId !== req.user.uid) {
      return res.status(403).json({ error: 'Access denied' });
    }

    const studentDoc = await db.collection('students').doc(appData.studentId).get();
    
    if (!studentDoc.exists) {
      return res.status(404).json({ error: 'Student not found' });
    }

    const documents = studentDoc.data().documents || {};

    res.json({ documents });
  } catch (error) {
    console.error('Error fetching documents:', error);
    res.status(500).json({ error: error.message });
  }
};

// Helper functions
async function findAndRankQualifiedStudents(jobId, jobData) {
  try {
    const studentsSnapshot = await db.collection('students')
      .where('studyStatus', '==', 'completed')
      .get();

    const qualifiedStudents = [];

    for (const doc of studentsSnapshot.docs) {
      const student = { id: doc.id, ...doc.data() };
      
      const matchResult = calculateAdvancedMatchScore(student, jobData.requirements);

      if (matchResult.totalScore >= (jobData.qualificationCriteria.minimumMatchScore || 70)) {
        qualifiedStudents.push({
          studentId: student.id,
          studentName: `${student.personalInfo.firstName} ${student.personalInfo.lastName}`,
          email: student.personalInfo.email || '',
          matchScore: matchResult.totalScore,
          scoreBreakdown: matchResult.breakdown,
          gpa: student.completionData?.gpa,
          fieldOfStudy: student.completionData?.fieldOfStudy
        });
      }
    }

    qualifiedStudents.sort((a, b) => b.matchScore - a.matchScore);

    return qualifiedStudents;
  } catch (error) {
    console.error('Error finding qualified students:', error);
    throw error;
  }
}

function identifyStrengthAreas(scoreBreakdown) {
  if (!scoreBreakdown) return [];
  const strengths = [];
  if (scoreBreakdown.academicScore >= 22) strengths.push('Strong Academic Performance');
  if (scoreBreakdown.certificatesScore >= 22) strengths.push('Excellent Certifications');
  if (scoreBreakdown.experienceScore >= 22) strengths.push('Relevant Work Experience');
  if (scoreBreakdown.fieldRelevanceScore >= 22) strengths.push('Perfect Field Match');
  return strengths;
}

function identifyConcernAreas(scoreBreakdown) {
  if (!scoreBreakdown) return [];
  const concerns = [];
  if (scoreBreakdown.academicScore < 15) concerns.push('Academic Performance');
  if (scoreBreakdown.certificatesScore < 10) concerns.push('Additional Certifications');
  if (scoreBreakdown.experienceScore < 10) concerns.push('Work Experience');
  if (scoreBreakdown.fieldRelevanceScore < 15) concerns.push('Field Relevance');
  return concerns;
}

function getStatusMessage(status, jobTitle, companyName) {
  const messages = {
    'interview': `Great news! ${companyName} wants to interview you for ${jobTitle}`,
    'rejected': `Thank you for applying to ${jobTitle} at ${companyName}`,
    'accepted': `Congratulations! You've been selected for ${jobTitle} at ${companyName}`,
    'on-hold': `Your application for ${jobTitle} at ${companyName} is under review`
  };
  return messages[status] || `Your application status for ${jobTitle} has been updated`;
}