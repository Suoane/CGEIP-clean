// backend/src/services/autoApplication.service.js
const { db } = require('../config/firebase');
const { sendEmail } = require('./email.service');
const autoMatching = require('./autoMatching.service');

class AutoApplicationService {
  /**
   * Auto-apply to top matching courses with student consent
   */
  async autoApplyToCourses(studentId, options = {}) {
    try {
      const {
        maxApplications = 2,
        minMatchScore = 80,
        autoSubmit = false,
        preferences = {}
      } = options;

      console.log(`ðŸ¤– Starting auto-application for student: ${studentId}`);

      // Get student data
      const studentDoc = await db.collection('students').doc(studentId).get();
      if (!studentDoc.exists()) {
        throw new Error('Student not found');
      }

      const studentData = studentDoc.data();

      // Check if documents are complete
      if (!studentData.documents?.transcript || !studentData.documents?.idCard) {
        return {
          success: false,
          error: 'Missing required documents',
          message: 'Please upload your transcript and ID card first'
        };
      }

      // Check existing applications count
      const existingAppsQuery = await db.collection('applications')
        .where('studentId', '==', studentId)
        .get();
      
      const currentApplicationCount = existingAppsQuery.size;
      const remainingSlots = maxApplications - currentApplicationCount;

      if (remainingSlots <= 0) {
        return {
          success: false,
          error: 'Application limit reached',
          message: `You have already submitted ${maxApplications} applications`
        };
      }

      // Find matching courses
      const matchingResult = await autoMatching.findMatchingCourses(studentData);
      
      if (!matchingResult.success || matchingResult.courses.length === 0) {
        return {
          success: false,
          error: 'No matching courses found',
          message: 'No courses currently match your qualifications'
        };
      }

      // Filter courses by match score and preferences
      let eligibleCourses = matchingResult.courses
        .filter(course => course.matchScore >= minMatchScore)
        .filter(course => {
          // Apply preference filters if specified
          if (preferences.institutionIds && preferences.institutionIds.length > 0) {
            return preferences.institutionIds.includes(course.institutionId);
          }
          if (preferences.excludePrivate && course.institution?.type === 'private') {
            return false;
          }
          if (preferences.maxFees && course.fees > preferences.maxFees) {
            return false;
          }
          return true;
        })
        .sort((a, b) => b.matchScore - a.matchScore)
        .slice(0, remainingSlots);

      if (eligibleCourses.length === 0) {
        return {
          success: false,
          error: 'No eligible courses after filtering',
          recommendations: matchingResult.courses.slice(0, 5)
        };
      }

      console.log(`âœ“ Found ${eligibleCourses.length} eligible courses for auto-apply`);

      // Create applications or drafts
      const applications = [];
      const batch = db.batch();

      for (const course of eligibleCourses) {
        // Check if already applied
        const existingApp = existingAppsQuery.docs.find(
          doc => doc.data().courseId === course.id
        );
        
        if (existingApp) {
          console.log(`âš ï¸ Already applied to: ${course.courseName}`);
          continue;
        }

        const applicationData = {
          studentId: studentId,
          institutionId: course.institutionId,
          courseId: course.id,
          status: autoSubmit ? 'pending' : 'draft',
          matchScore: course.matchScore,
          autoGenerated: true,
          documents: studentData.documents || {},
          personalInfo: studentData.personalInfo || {},
          academicInfo: studentData.academicInfo || {},
          preferences: studentData.preferences || {},
          appliedAt: autoSubmit ? new Date() : null,
          createdAt: new Date(),
          applicationNumber: `APP-${Date.now()}-${studentId.slice(0, 6).toUpperCase()}`,
          matchingReasons: course.reasons || [],
          subjectAnalysis: course.subjectAnalysis || null
        };

        const appRef = db.collection('applications').doc();
        batch.set(appRef, applicationData);

        applications.push({
          id: appRef.id,
          ...applicationData,
          course: {
            id: course.id,
            name: course.courseName,
            institution: course.institution?.name,
            matchScore: course.matchScore
          }
        });

        console.log(`âœ“ ${autoSubmit ? 'Applied' : 'Created draft'} for: ${course.courseName}`);
      }

      // Update student application count if auto-submitted
      if (autoSubmit && applications.length > 0) {
        const studentRef = db.collection('students').doc(studentId);
        batch.update(studentRef, {
          applicationCount: currentApplicationCount + applications.length,
          lastApplicationDate: new Date(),
          autoApplicationsSubmitted: (studentData.autoApplicationsSubmitted || 0) + applications.length,
          updatedAt: new Date()
        });
      }

      await batch.commit();

      // Send notification email
      if (autoSubmit && applications.length > 0) {
        await this.sendAutoApplicationConfirmation(studentData, applications);
      }

      return {
        success: true,
        applicationsCreated: applications.length,
        applications: applications,
        status: autoSubmit ? 'submitted' : 'draft',
        message: autoSubmit 
          ? `Successfully applied to ${applications.length} courses!`
          : `${applications.length} draft applications created for your review`,
        remainingSlots: remainingSlots - applications.length
      };

    } catch (error) {
      console.error('âŒ Auto-application error:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Auto-apply to jobs for completed students
   */
  async autoApplyToJobs(studentId, options = {}) {
    try {
      const {
        maxApplications = 5,
        minMatchScore = 70,
        autoSubmit = false,
        jobPreferences = {}
      } = options;

      console.log(`ðŸ¤– Starting job auto-application for: ${studentId}`);

      const studentDoc = await db.collection('students').doc(studentId).get();
      if (!studentDoc.exists()) {
        throw new Error('Student not found');
      }

      const studentData = studentDoc.data();

      // Must be completed student
      if (studentData.studyStatus !== 'completed') {
        return {
          success: false,
          error: 'Student must complete studies first'
        };
      }

      // Find matching jobs
      const matchingResult = await autoMatching.findMatchingJobs(studentData);
      
      if (!matchingResult.success || matchingResult.jobs.length === 0) {
        return {
          success: false,
          error: 'No matching jobs found'
        };
      }

      // Filter and sort jobs
      let eligibleJobs = matchingResult.jobs
        .filter(job => job.matchScore >= minMatchScore)
        .filter(job => {
          if (jobPreferences.locations && jobPreferences.locations.length > 0) {
            return jobPreferences.locations.some(loc => 
              job.location.toLowerCase().includes(loc.toLowerCase())
            );
          }
          if (jobPreferences.employmentTypes && jobPreferences.employmentTypes.length > 0) {
            return jobPreferences.employmentTypes.includes(job.employmentType);
          }
          if (jobPreferences.minSalary && job.salaryRange?.min) {
            return job.salaryRange.min >= jobPreferences.minSalary;
          }
          return true;
        })
        .sort((a, b) => b.matchScore - a.matchScore)
        .slice(0, maxApplications);

      const jobApplications = [];
      const batch = db.batch();

      for (const job of eligibleJobs) {
        const jobAppData = {
          studentId: studentId,
          companyId: job.companyId,
          jobId: job.id,
          status: autoSubmit ? 'pending' : 'draft',
          matchScore: job.matchScore,
          scoreBreakdown: job.scoreBreakdown,
          autoGenerated: true,
          resume: studentData.completionData?.transcript || null,
          certificates: studentData.completionData?.certificates || [],
          coverLetter: this.generateCoverLetter(studentData, job),
          appliedAt: autoSubmit ? new Date() : null,
          createdAt: new Date()
        };

        const jobAppRef = db.collection('jobApplications').doc();
        batch.set(jobAppRef, jobAppData);

        jobApplications.push({
          id: jobAppRef.id,
          ...jobAppData,
          job: {
            id: job.id,
            title: job.title,
            company: job.company?.companyName,
            matchScore: job.matchScore
          }
        });
      }

      await batch.commit();

      return {
        success: true,
        applicationsCreated: jobApplications.length,
        applications: jobApplications,
        status: autoSubmit ? 'submitted' : 'draft',
        message: `${autoSubmit ? 'Applied to' : 'Created drafts for'} ${jobApplications.length} jobs`
      };

    } catch (error) {
      console.error('âŒ Job auto-application error:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Generate personalized cover letter
   */
  generateCoverLetter(studentData, job) {
    const { personalInfo, completionData, academicInfo } = studentData;
    
    return `Dear Hiring Manager,

I am writing to express my strong interest in the ${job.title} position at ${job.company?.companyName}.

I recently completed my ${completionData?.fieldOfStudy || 'studies'} with a GPA of ${completionData?.gpa || 'strong academic performance'} from ${academicInfo?.institutionName || 'a reputable institution'}. My educational background and skills align perfectly with the requirements of this role.

Key qualifications:
- Strong foundation in ${completionData?.fieldOfStudy || 'my field'}
- Proven academic excellence with a ${completionData?.gpa || 'strong'} GPA
- Relevant coursework and practical experience
- Excellent problem-solving and communication skills

I am excited about the opportunity to contribute to ${job.company?.companyName} and would welcome the chance to discuss how my background and skills would be a great fit for your team.

Thank you for your consideration.

Best regards,
${personalInfo?.firstName} ${personalInfo?.lastName}
${personalInfo?.email}
${personalInfo?.phone}`;
  }

  /**
   * Send confirmation email
   */
  async sendAutoApplicationConfirmation(studentData, applications) {
    try {
      const email = studentData.personalInfo?.email;
      if (!email) return;

      const courseList = applications.map((app, idx) => 
        `${idx + 1}. ${app.course.name} at ${app.course.institution} (${app.course.matchScore}% match)`
      ).join('\n');

      await sendEmail({
        to: email,
        subject: 'âœ… Your Applications Have Been Submitted!',
        text: `Hi ${studentData.personalInfo?.firstName},

Great news! Your applications have been automatically submitted to the following courses:

${courseList}

These courses were selected based on your qualifications and have high match scores. The institutions will review your applications and contact you soon.

You can track your application status in your dashboard.

Best of luck!

The Student Placement System Team`,
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #10b981;">âœ… Applications Submitted Successfully!</h2>
            <p>Hi ${studentData.personalInfo?.firstName},</p>
            <p>Great news! Your applications have been automatically submitted to:</p>
            <div style="background: #f9fafb; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
              ${applications.map((app, idx) => `
                <div style="margin: 0.5rem 0; padding: 0.5rem; background: white; border-radius: 4px;">
                  <strong>${idx + 1}. ${app.course.name}</strong><br/>
                  <span style="color: #6b7280;">${app.course.institution}</span><br/>
                  <span style="color: #10b981; font-weight: 600;">${app.course.matchScore}% Match</span>
                </div>
              `).join('')}
            </div>
            <p>These courses were selected based on your qualifications and have high match scores.</p>
            <p style="margin-top: 2rem;">
              <a href="${process.env.FRONTEND_URL}/student/applications" 
                 style="background: #667eea; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; display: inline-block;">
                Track Applications
              </a>
            </p>
          </div>
        `
      });

      console.log('âœ“ Confirmation email sent');
    } catch (error) {
      console.error('Failed to send confirmation email:', error);
    }
  }

  /**
   * Get auto-application suggestions without applying
   */
  async getAutoApplicationSuggestions(studentId) {
    try {
      const studentDoc = await db.collection('students').doc(studentId).get();
      if (!studentDoc.exists()) {
        throw new Error('Student not found');
      }

      const studentData = studentDoc.data();
      const matchingResult = await autoMatching.findMatchingCourses(studentData);

      const suggestions = matchingResult.courses
        .filter(course => course.matchScore >= 70)
        .slice(0, 5)
        .map(course => ({
          courseId: course.id,
          courseName: course.courseName,
          institution: course.institution?.name,
          matchScore: course.matchScore,
          reasons: course.reasons,
          recommendation: course.recommendationLevel,
          estimatedAcceptanceProbability: this.calculateAcceptanceProbability(course.matchScore)
        }));

      return {
        success: true,
        suggestions: suggestions,
        message: `Found ${suggestions.length} recommended courses for auto-application`
      };

    } catch (error) {
      console.error('Error getting suggestions:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Calculate estimated acceptance probability
   */
  calculateAcceptanceProbability(matchScore) {
    if (matchScore >= 90) return 'Very High (85-95%)';
    if (matchScore >= 80) return 'High (70-85%)';
    if (matchScore >= 70) return 'Good (60-75%)';
    if (matchScore >= 60) return 'Moderate (45-60%)';
    return 'Fair (30-45%)';
  }

  /**
   * Batch auto-apply for multiple students (admin function)
   */
  async batchAutoApply(studentIds, options = {}) {
    const results = [];
    
    for (const studentId of studentIds) {
      try {
        const result = await this.autoApplyToCourses(studentId, options);
        results.push({
          studentId,
          success: result.success,
          applicationsCreated: result.applicationsCreated || 0,
          message: result.message
        });
      } catch (error) {
        results.push({
          studentId,
          success: false,
          error: error.message
        });
      }
    }

    return {
      success: true,
      totalProcessed: studentIds.length,
      results: results,
      summary: {
        successful: results.filter(r => r.success).length,
        failed: results.filter(r => !r.success).length,
        totalApplications: results.reduce((sum, r) => sum + (r.applicationsCreated || 0), 0)
      }
    };
  }
}

module.exports = new AutoApplicationService();